# Primary Findings: Contingency Planning for External PQC Dependencies (Addressing G4 Critique)

**Date Compiled:** 2025-06-02
**Research Focus:** Contingency planning for external PQC dependencies (GPG, PQC-TLS Proxies, PQC Signing Tools) if primary tools are immature or unavailable.
**Source:** AI Search (Perplexity MCP) - Query: "Contingency plans and alternative approaches for PQC integration if primary external dependencies are immature or unavailable. Specifically: 1. If GPG PQC support remains distant: alternatives for user-side data-at-rest PQC encryption. 2. If PQC-TLS reverse proxies (Nginx/Caddy with PQC OpenSSL) are unstable: alternative methods for securing Fava's client-server communication with PQC. 3. If dedicated PQC command-line signing tools for WASM are lacking: alternative methods for ensuring WASM module integrity using PQC signatures. Focus on practical, implementable solutions for a Python/Svelte application like Fava. Cite PQC migration strategies or community best practices."

This document outlines contingency plans and alternative approaches for Fava's PQC integration if primary external dependencies prove immature or unavailable in the project's timeframe.

## 1. Contingency for GPG PQC Data-at-Rest Encryption

**Scenario:** Official GnuPG (GPG) support for NIST PQC algorithms (e.g., Kyber for KEMs, Dilithium for signatures) remains distant or unstable.

**Alternative Approaches for User-Side Data-at-Rest PQC Encryption:**

*   **Option A: Fava-Guided Hybrid Encryption with External PQC Tools/Libraries:**
    *   **Concept:** Fava does not perform PQC encryption itself but guides users to employ a hybrid strategy using existing PQC libraries for the PQC part and classical GPG for the classical part.
    *   **Process for User:**
        1.  User encrypts their Beancount file using a strong symmetric cipher (e.g., AES-256-GCM).
        2.  The symmetric key is protected/wrapped twice:
            *   Once using their classical GPG public key (e.g., RSA, ECC).
            *   Once using a PQC KEM (e.g., Kyber-768) with a PQC public key they manage. This PQC operation would be done using a script or tool based on `oqs-python` or a similar library.
        3.  Both wrapped keys are stored. Fava would need to be able to decrypt using *either* method, prioritizing PQC if available.
    *   **Fava's Role:**
        *   Provide clear documentation and potentially helper scripts (Python-based) for users to perform the PQC KEM wrapping of the symmetric key.
        *   Implement decryption logic that can handle the PQC-wrapped key (using `oqs-python`) if PQC metadata is present, falling back to classical GPG decryption.
    *   **Libraries:** `oqs-python` for PQC KEM operations (Kyber), standard GPG for classical operations.
    *   **Pros:** Allows users to adopt PQC for new files, leverages existing PQC libraries.
    *   **Cons:** Complex for users (managing PQC keys, running scripts), Fava needs robust logic to handle dual decryption paths.

*   **Option B: Utilize Standalone PQC Encryption Tools:**
    *   **Concept:** Users employ third-party or community-developed standalone PQC encryption tools that produce files in a defined PQC format. Fava would then need to support decrypting this specific format.
    *   **Tools:** This depends on the emergence of user-friendly, cross-platform PQC file encryption tools. Projects like CLEARâ„¢ Cryptosystem SDK (if it offers a suitable command-line utility) or tools built directly from `liboqs` or PQClean could be candidates.
    *   **Fava's Role:** Support decryption for one or more well-defined PQC file formats generated by these external tools.
    *   **Pros:** Potentially simpler for users if good tools emerge.
    *   **Cons:** Dependency on external tool availability and standardization of formats.

*   **Option C: Application-Level PQC Encryption (More Involved for Fava):**
    *   **Concept:** Fava itself implements PQC encryption/decryption for Beancount files, independent of GPG.
    *   **Process:** Fava would manage PQC key pairs (or guide users through generation/import), use `oqs-python` for KEM (Kyber) to wrap a symmetric data encryption key (DEK), and use AES-GCM to encrypt the file content with the DEK.
    *   **Pros:** Full control over the PQC implementation, potentially better UX if key management is handled well.
    *   **Cons:** Significant development effort for Fava, responsibility for secure key management, moves away from GPG standard.

## 2. Contingency for PQC-TLS Reverse Proxies

**Scenario:** PQC-TLS enabled reverse proxies (Nginx/Caddy compiled with PQC-OpenSSL) are unstable, difficult to configure, or not widely available.

**Alternative Approaches for Securing Client-Server Communication with PQC:**

*   **Option A: Application-Layer Hybrid Key Exchange (Python Backend):**
    *   **Concept:** Fava's Python backend, when initiating or handling a connection that needs PQC protection beyond standard TLS, performs an additional PQC KEM operation at the application layer *after* the classical TLS handshake is complete.
    *   **Process:**
        1.  Standard TLS 1.3 handshake establishes a secure classical channel.
        2.  Fava client (JS) and server (Python) perform an explicit PQC KEM exchange (e.g., X25519 for classical part, Kyber-768 for PQC part, using `liboqs-js` and `oqs-python`).
        3.  The derived hybrid shared secret is used to encrypt/decrypt the actual application data (e.g., API requests/responses) *within* the already TLS-encrypted channel. This provides an additional layer of PQC security for the payload.
    *   **Pros:** Independent of reverse proxy PQC capabilities, full control within Fava.
    *   **Cons:** Adds complexity to the application protocol, potential performance overhead for every request/response if not managed carefully (e.g., derive a session key from the PQC KEM for a period). Does not protect TLS handshake metadata itself with PQC.

*   **Option B: Focus on PQC for Sensitive API Endpoints Only:**
    *   **Concept:** Similar to Option A, but apply the application-layer PQC KEM and encryption only to specific API endpoints that handle highly sensitive data, rather than all traffic.
    *   **Pros:** Reduces performance impact.
    *   **Cons:** Selective security.

*   **Option C: WebSockets with Application-Layer PQC:**
    *   **Concept:** If Fava uses WebSockets for some communications, the WebSocket connection (established over classical TLS) could then implement an application-level PQC key agreement to secure the WebSocket message stream.
    *   **Pros:** Can be efficient for persistent connections.
    *   **Cons:** Only applicable if WebSockets are a suitable communication pattern for Fava.

## 3. Contingency for PQC Command-Line Signing Tool for WASM

**Scenario:** A mature, dedicated PQC command-line signing tool for WASM modules is lacking or difficult to integrate into the build process.

**Alternative Approaches for Ensuring WASM Module Integrity with PQC:**

*   **Option A: Python Script using `oqs-python` in Build Process:**
    *   **Concept:** Create a Python script that uses `oqs-python` to perform PQC signing. This script is called during Fava's frontend build process.
    *   **Process:**
        1.  The build script hashes the WASM module.
        2.  The Python script takes the hash, loads a PQC private key (e.g., Dilithium3), and generates a PQC signature using `oqs.Signature().sign()`.
        3.  The signature is saved (e.g., to a file or embedded in metadata).
    *   **Pros:** Keeps PQC operations within the Python ecosystem, leverages `oqs-python`.
    *   **Cons:** Requires `oqs-python` and its dependencies to be available in the build environment.

*   **Option B: Compile Minimal C Signer from PQClean/liboqs:**
    *   **Concept:** Compile a minimal command-line signing utility from the reference C code of the chosen PQC signature algorithm (e.g., Dilithium from PQClean or `liboqs` examples).
    *   **Process:** This utility would take the WASM file (or its hash) and a private key file as input and output a signature file.
    *   **Pros:** Potentially lightweight, no Python dependency for the signing step itself.
    *   **Cons:** Requires C compilation toolchain in the build environment, more effort to create and maintain this custom tool.

*   **Option C: Hybrid Signature Scheme (Classical Tool + PQC Script):**
    *   **Concept:** Sign the WASM module with a classical signature tool (e.g., `gpg` with an ECDSA key, or `openssl dgst`) *and* with a PQC signature using one of the methods above (Option A or B).
    *   **Frontend Verification:** The frontend would verify both signatures. This provides a fallback if PQC verification has issues or for environments where PQC libs are not yet deployed on the client.
    *   **Pros:** Robustness, phased rollout.
    *   **Cons:** Larger signature overhead, more complex verification logic on the client.

## General Contingency Principles:

*   **Prioritize Hybrid Approaches:** As recommended by NIST and communities like Cloudflare, hybrid schemes (classical + PQC) offer the best balance of forward security and backward compatibility during the transition.
*   **Cryptographic Agility:** Fava's design should allow for PQC algorithms and parameters to be updated as standards and libraries mature.
*   **User Education:** Clearly communicate to users the PQC capabilities, limitations, and any steps they need to take (e.g., for key management).
*   **Monitor Ecosystem:** Continuously monitor the development of GPG, OpenSSL, PQC libraries (`liboqs`), and browser PQC support.

These contingency plans aim to provide Fava with practical paths forward even if the ideal external PQC tooling is not immediately available or stable.